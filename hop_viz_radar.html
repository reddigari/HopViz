<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>TITLE</title>
    <meta name="description" content="DESCRIPTION">
    <link rel="stylesheet" href="PATH">
    <script src="d3/d3.min.js"></script>
    <!--[if lt IE 9]>
       <script src = "http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
     <![endif]-->
    <style>
        body {
            font-family: sans-serif;
        }
        /*.svg-container {
            display: inline-block;
            position: relative;
            width: 100%;
            padding-bottom: 100%;
            vertical-align: top;
            overflow: hidden;
        }*/
        /*.svg-content-responsive {
            display: inline-block;
            position: absolute;
            top: 10px;
            left: 0;
        }*/
    </style>
</head>

<body>
    <div id="chartId"></div>
    <script>
        var id = "#chartId";

        var cfg = {
            w: 600, //Width of the circle
            h: 600, //Height of the circle
            margin: {
                top: 50,
                right: 50,
                bottom: 50,
                left: 50
            }, //The margins of the SVG
            levels: 3, //How many levels or inner circles should there be drawn
            maxValue: 9, //What is the value that the biggest circle will represent
            labelFactor: 1.1, //How much farther than the radius of the outer circle should the labels be placed
            wrapWidth: 60, //The number of pixels after which a label needs to be given a new line
            opacityArea: 0.35, //The opacity of the area of the blob
            dotRadius: 4, //The size of the colored circles of each blog
            opacityCircles: 0.1, //The opacity of the circles of each blob
            strokeWidth: 2, //The width of the stroke around each blob
            roundStrokes: false, //If true the area and stroke will follow a round path (cardinal-closed)
            color: d3.scaleOrdinal(d3.schemeCategory10) //Color function
        };

        var dims = ['CITRUS', 'TROPICAL FRUIT', 'STONE FRUIT', 'APPLE-PEAR',
            'MELON', 'BERRY', 'FLORAL', 'SPICY-HERBAL', 'PINE', 'RESINOUS',
            'GRASSY', 'EARTHY-WOODY', 'ONION-GARLIC', 'DANK-CATTY'
        ];

        var senses = ["aroma", "flavor"];

        var maxValue = cfg.maxValue;
        var allAxis = dims, //Names of each axis
            total = allAxis.length, //The number of different axes
            radius = Math.min(cfg.w / 2, cfg.h / 2), //Radius of the outermost circle
            //Format = d3.format('%'), //Percentage formatting
            angleSlice = Math.PI * 2 / total; //The width in radians of each "slice"

        //Scale for the radius
        var rScale = d3.scaleLinear()
            .range([0, radius])
            .domain([0, maxValue]);

        //Initiate the radar chart SVG
        var svg = d3.select(id).append("svg")
            .attr("width", cfg.w + cfg.margin.left + cfg.margin.right)
            .attr("height", cfg.h + cfg.margin.top + cfg.margin.bottom)
            .attr("class", "radar" + id);
        //Append a g element
        var g = svg.append("g")
            .attr("transform", "translate(" + (cfg.w / 2 + cfg.margin.left) + "," + (cfg.h / 2 + cfg.margin.top) + ")");
        //Wrapper for the grid & axes
        var axisGrid = g.append("g").attr("class", "axisWrapper");

        //Draw the background circles
        axisGrid.selectAll(".levels")
            .data(d3.range(1, (cfg.levels + 1)).reverse())
            .enter()
            .append("circle")
            .attr("class", "gridCircle")
            .attr("r", function(d, i) {
                return radius / cfg.levels * d;
            })
            .style("fill", "#CDCDCD")
            .style("stroke", "#CDCDCD")
            .style("fill-opacity", cfg.opacityCircles);
        // .style("filter", "url(#glow)");

        //Text indicating at what % each level is
        axisGrid.selectAll(".axisLabel")
            .data(d3.range(1, (cfg.levels + 1)).reverse())
            .enter().append("text")
            .attr("class", "axisLabel")
            .attr("x", 4)
            .attr("y", function(d) {
                return -d * radius / cfg.levels;
            })
            .attr("dy", "0.4em")
            .style("font-size", "10px")
            .attr("fill", "#737373")
            .text(function(d, i) {
                return maxValue * d / cfg.levels;
            });

        //Create the straight lines radiating outward from the center
        var axis = axisGrid.selectAll(".axis")
            .data(allAxis)
            .enter()
            .append("g")
            .attr("class", "axis");
        //Append the lines
        axis.append("line")
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", function(d, i) {
                return rScale(maxValue * 1.1) * Math.cos(angleSlice * i - Math.PI / 2);
            })
            .attr("y2", function(d, i) {
                return rScale(maxValue * 1.1) * Math.sin(angleSlice * i - Math.PI / 2);
            })
            .attr("class", "line")
            .style("stroke", "white")
            .style("stroke-width", "2px");

        //Append the labels at each axis
        axis.append("text")
            .attr("class", "legend")
            .style("font-size", "11px")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .attr("x", function(d, i) {
                return rScale(maxValue * cfg.labelFactor) * Math.cos(angleSlice * i - Math.PI / 2);
            })
            .attr("y", function(d, i) {
                return rScale(maxValue * cfg.labelFactor) * Math.sin(angleSlice * i - Math.PI / 2);
            })
            .text(function(d) {
                return d
            })
            .call(wrap, cfg.wrapWidth);

        var radarLine = d3.radialLine()
      		// .interpolate("linear-closed")
      		.radius(function(d) { return rScale(d.value); })
      		.angle(function(d,i) {	return i*angleSlice; });

        radarLine.curve(d3.curveLinearClosed);

        d3.json("hop_data/cascade.json", function(data) {

            var newData = [];
            senses.forEach(function(s) {
              var senseHolder = []
              data.forEach(function(d) {
                senseHolder.push({axis: d.dimension, value: d3.mean(d[s])});
              })
              newData.push(senseHolder);
            });
            console.log(newData);

            data = newData;

            var blobWrapper = g.selectAll(".radarWrapper")
          		.data(data)
          		.enter().append("g")
          		.attr("class", "radarWrapper");
            blobWrapper.append("path")
          		.attr("class", "radarStroke")
          		.attr("d", function(d,i) { return radarLine(d); })
          		.style("stroke-width", cfg.strokeWidth + "px")
          		.style("stroke", function(d,i) { return cfg.color(i); })
          		.style("fill", "none");
          		// .style("filter" , "url(#glow)");

          	//Append the circles
          	blobWrapper.selectAll(".radarCircle")
          		.data(function(d,i) { return d; })
          		.enter().append("circle")
          		.attr("class", "radarCircle")
          		.attr("r", cfg.dotRadius)
          		.attr("cx", function(d,i){ return rScale(d.value) * Math.cos(angleSlice*i - Math.PI/2); })
          		.attr("cy", function(d,i){ return rScale(d.value) * Math.sin(angleSlice*i - Math.PI/2); })
          		.style("fill", function(d,i,j) { return cfg.color(j); })
          		.style("fill-opacity", 0.8);

        })







        /////////////////////////////////////////////////////////
        /////////////////// Helper Function /////////////////////
        /////////////////////////////////////////////////////////

        //Taken from http://bl.ocks.org/mbostock/7555321
        //Wraps SVG text
        function wrap(text, width) {
            text.each(function() {
                var text = d3.select(this),
                    words = text.text().split(/[\s\-]/).reverse(),
                    word,
                    line = [],
                    lineNumber = 0,
                    lineHeight = 1.4, // ems
                    y = text.attr("y"),
                    x = text.attr("x"),
                    dy = parseFloat(text.attr("dy")),
                    tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");

                while (word = words.pop()) {
                    line.push(word);
                    tspan.text(line.join(" "));
                    if (tspan.node().getComputedTextLength() > width) {
                        line.pop();
                        tspan.text(line.join(" "));
                        line = [word];
                        tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                    }
                }
            });
        } //wrap
    </script>


</body>

</html>
