<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>TITLE</title>
    <meta name="description" content="DESCRIPTION">
    <link rel="stylesheet" href="PATH">
    <script src="d3/d3.min.js"></script>
    <!--[if lt IE 9]>
       <script src = "http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
     <![endif]-->
    <style>
        body {
            font-family: sans-serif;
        }

        div.tooltip {
            position: absolute;
            text-align: center;
            vertical-align: middle;
            width: 100px;
            height: auto;
            padding: 2px;
            font: 12px sans-serif;
            color: white;
            background: black;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="optionsId">
        <input type="radio" class="showHideOption" name="showOrHide" value="show" checked> Show All Hops
        <br>
        <input type="radio" class="showHideOption" name="showOrHide" value="hide"> Hide Unselected Hops
    </div>
    <div class="tooltip" style="opacity: 0"></div>
    <div id="chartId" style="display: inline-block;"></div>
    <div id="legendId" style="display: inline-block; padding-left: 25px"></div>

    <script>
        var id = "#chartId";

        var cfg = {
            w: 600, //Width of the circle
            h: 600, //Height of the circle
            margin: {
                top: 50,
                right: 50,
                bottom: 50,
                left: 50
            }, //The margins of the SVG
            levels: 3, //How many levels or inner circles should there be drawn
            maxValue: 7, //What is the value that the biggest circle will represent
            labelFactor: 1.1, //How much farther than the radius of the outer circle should the labels be placed
            wrapWidth: 60, //The number of pixels after which a label needs to be given a new line
            opacityArea: 0.35, //The opacity of the area of the blob
            dotRadius: 4, //The size of the colored circles of each blog
            opacityCircles: 0.05, //The opacity of the circles of each blob
            strokeWidth: 1, //The width of the stroke around each blob
            roundStrokes: false, //If true the area and stroke will follow a round path (cardinal-closed)
            color: d3.scaleOrdinal(d3.schemeCategory20), //Color function
            radarColor: {show: "#002057", hide: "none"},
            radarOpacity: 0.4
        };

        var dims = ['CITRUS', 'TROPICAL FRUIT', 'STONE FRUIT', 'APPLE-PEAR',
            'MELON', 'BERRY', 'FLORAL', 'SPICY-HERBAL', 'PINE', 'RESINOUS',
            'GRASSY', 'EARTHY-WOODY', 'ONION-GARLIC', 'DANK-CATTY'
        ];

        var senses = ["aroma", "flavor"];

        var maxValue = cfg.maxValue;
        var allAxis = dims, //Names of each axis
            total = allAxis.length, //The number of different axes
            radius = Math.min(cfg.w / 2, cfg.h / 2), //Radius of the outermost circle
            //Format = d3.format('%'), //Percentage formatting
            angleSlice = Math.PI * 2 / total; //The width in radians of each "slice"

        //Scale for the radius
        var rScale = d3.scaleLinear()
            .range([0, radius])
            .domain([0, maxValue]);

        //Initiate the radar chart SVG
        var svg = d3.select(id).append("svg")
            .attr("width", cfg.w + cfg.margin.left + cfg.margin.right)
            .attr("height", cfg.h + cfg.margin.top + cfg.margin.bottom)
            .attr("class", "radar" + id);
        //Append a g element
        var g = svg.append("g")
            .attr("transform", "translate(" + (cfg.w / 2 + cfg.margin.left) + "," + (cfg.h / 2 + cfg.margin.top) + ")");

        var legend = d3.select("#legendId").append("svg")
            .attr("width", 300)
            .attr("height", 600)
            .append("g");

        //Wrapper for the grid & axes
        var axisGrid = g.append("g").attr("class", "axisWrapper");

        //Draw the background circles
        axisGrid.selectAll(".levels")
            .data(d3.range(1, (cfg.levels + 1)).reverse())
            .enter()
            .append("circle")
            .attr("class", "gridCircle")
            .attr("r", function(d, i) {
                return radius / cfg.levels * d;
            })
            .style("fill", "#CDCDCD")
            // .style("fill", "#247724")
            .style("stroke", "#CDCDCD")
            .style("fill-opacity", cfg.opacityCircles);
        // .style("filter", "url(#glow)");

        //Text indicating at what % each level is
        axisGrid.selectAll(".axisLabel")
            .data(d3.range(1, (cfg.levels + 1)).reverse())
            .enter().append("text")
            .attr("class", "axisLabel")
            .attr("x", 4)
            .attr("y", function(d) {
                return -d * radius / cfg.levels;
            })
            .attr("dy", "0.4em")
            .style("font-size", "10px")
            .attr("fill", "#737373")
            .text(function(d, i) {
                // return maxValue * d / cfg.levels;
                return d3.format(".2f")(maxValue * d / cfg.levels);
            });

        //Create the straight lines radiating outward from the center
        var axis = axisGrid.selectAll(".axis")
            .data(allAxis)
            .enter()
            .append("g")
            .attr("class", "axis");
        //Append the lines
        axis.append("line")
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", function(d, i) {
                return rScale(maxValue * 1.1) * Math.cos(angleSlice * i - Math.PI / 2);
            })
            .attr("y2", function(d, i) {
                return rScale(maxValue * 1.1) * Math.sin(angleSlice * i - Math.PI / 2);
            })
            .attr("class", "line")
            .style("stroke", "white")
            .style("stroke-width", "2px");

        //Append the labels at each axis
        axis.append("text")
            .attr("class", "legend")
            .style("font-size", "11px")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .attr("x", function(d, i) {
                return rScale(maxValue * cfg.labelFactor) * Math.cos(angleSlice * i - Math.PI / 2);
            })
            .attr("y", function(d, i) {
                return rScale(maxValue * cfg.labelFactor) * Math.sin(angleSlice * i - Math.PI / 2);
            })
            .text(function(d) {
                return d
            })
            .call(wrap, cfg.wrapWidth);

        var radarLine = d3.radialLine()
            // .interpolate("linear-closed")
            .radius(function(d) {
                return rScale(d.value);
            })
            .angle(function(d, i) {
                return i * angleSlice;
            });

        radarLine.curve(d3.curveLinearClosed); // new version of interpolation I think

        function extractAvgs(hopData, sense) {
            return hopData.data.map(function(d) {
                return {
                    axis: d.dimension,
                    value: d3.mean(d[sense])
                }
            })
        }

        var showOrHide = "hide",
            vizStatus = {};

        function addData() {
            d3.json("hop_data/all_hop_data.json", function(data) {

                data.forEach(function(d) {
                    vizStatus[d.hop] = 0;
                });

                var blobWrapper = g.selectAll(".radarWrapper")
                    .data(data, function(d, i) {
                        return d.hop;
                    });

                blobWrapper
                    .enter().append("g")
                    .attr("class", "radarWrapper")
                    .append("path")
                    .attr("class", "radarStroke")
                    .attr("id", function(d) {
                        return d.hop + "Radar";
                    })
                    // .attr("d", function(d,i) { return radarLine(d); })
                    .attr("d", function(d, i) {
                        return radarLine(extractAvgs(d, "flavor"));
                    })
                    // .style("stroke-width", cfg.strokeWidth)
                    .style("stroke-opacity", cfg.radarOpacity)
                    // .style("stroke", function(d,i) { return cfg.color(i); })
                    .style("stroke", cfg.radarColor[showOrHide])
                    .style("stroke-width", 1)
                    .style("fill", "none")
                    .on("mouseover", function(d) {
                        if (!vizStatus[d.hop]) {
                            alterRadar(this.id, "black", 4, 1.0);
                        }
                        tooltip.html(d.hop.toUpperCase())
                            .style("opacity", 1.0)
                            .style("left", (d3.event.pageX + 10) + "px")
                            .style("top", (d3.event.pageY) + "px");
                    })
                    .on("mouseout", function(d) {
                        tooltip.style("opacity", 0);
                        if (!vizStatus[d.hop]) {
                            alterRadar(this.id, cfg.radarColor[showOrHide], cfg.strokeWidth, cfg.radarOpacity);
                        }
                    });

                var hopLabels = legend.selectAll(".hopLabel")
                    .data(data.map(function(d) {
                        return d.hop;
                    }), function(d) {
                        return d;
                    })
                    .enter()
                    .append("g")
                    .attr("class", "hopLabelGroup")
                    .attr("transform", function(d, i) {
                        return "translate(0," + 20 * i + ")";
                    });

                hopLabels.append("text")
                    // .attr("clicked", 0) //custom attribute
                    .attr("class", "hopLabel")
                    .style("cursor", "pointer")
                    .text(function(d) {
                        return d.toUpperCase();
                    })
                    // .attr("y", function(d, i) { return 30*i; })
                    .on("mouseover", function(d, i) {
                        if (!vizStatus[d]) {
                            alterRadar(d + "Radar", "black", 4, 1.0)
                        }
                    })
                    .on("mouseout", function(d, i) {
                        if (!vizStatus[d]) {
                            alterRadar(d + "Radar", cfg.radarColor[showOrHide], cfg.strokeWidth, cfg.radarOpacity)
                        }
                    })
                    .on("click", function(d, i) {
                        var truth = vizStatus[d]
                        var label = d3.select(this);
                        //   var truth = parseInt(label.attr("clicked"));
                        if (!truth) {
                            label.style("fill", cfg.color(i))
                            alterRadar(d + "Radar", cfg.color(i), 4, 1.0)
                        } else {
                            label.style("fill", "black")
                            alterRadar(d + "Radar", cfg.radarColor[showOrHide], cfg.strokeWidth, cfg.radarOpacity)
                        };
                        //   label.attr("clicked", (truth + 1) % 2)
                        vizStatus[d] = (truth + 1) % 2;
                    });

                // var hopLabels = d3.select("#legendId").selectAll(".hopLabel")
                //     .data(data.map(function(d) { return d.hop; }), function(d) { return d; })
                //     .enter()
                //     .append("input")
                //     .attr("class", "hopLabel")
                //     .attr("type", "checkbox")
                //     .html(function(d) { return d.toUpperCase(); })
                //     .attr("y", function(d, i) { return 30*i; })
                //     .on("mouseover", function(d, i) {
                //       alterRadar(d+"Radar", "black", 4, 1.0)
                //     })
                //     .on("mouseout", function(d, i) {
                //       alterRadar(d+"Radar", cfg.radarColor, cfg.strokeWidth, cfg.radarOpacity)
                //     });

            }) //json callback
        } // addData

        var tooltip = d3.select(".tooltip")
        addData();
        d3.selectAll(".showHideOption")
            .on("change", function() {
                showOrHide = d3.select("input[name='showOrHide']:checked").property("value");
                d3.selectAll(".radarStroke").each(function(d) {
                    if (!vizStatus[d.hop]) d3.select(this).style("stroke", cfg.radarColor[showOrHide]);
                })
            })

        function alterRadar(hopId, color, thickness, opacity) {
            d3.select("#" + hopId)
                .style("stroke-width", thickness)
                .style("stroke", color)
                .style("stroke-opacity", opacity);
        }
        /////////////////////////////////////////////////////////
        /////////////////// Helper Function /////////////////////
        /////////////////////////////////////////////////////////
        //Taken from http://bl.ocks.org/mbostock/7555321
        //Wraps SVG text
        function wrap(text, width) {
            text.each(function() {
                var text = d3.select(this),
                    words = text.text().split(/[\s\-]/).reverse(),
                    word,
                    line = [],
                    lineNumber = 0,
                    lineHeight = 1.4, // ems
                    y = text.attr("y"),
                    x = text.attr("x"),
                    dy = parseFloat(text.attr("dy")),
                    tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");

                while (word = words.pop()) {
                    line.push(word);
                    tspan.text(line.join(" "));
                    if (tspan.node().getComputedTextLength() > width) {
                        line.pop();
                        tspan.text(line.join(" "));
                        line = [word];
                        tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                    }
                }
            });
        }
    </script>


</body>

</html>
