<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>TITLE</title>
    <meta name="description" content="DESCRIPTION">
    <link rel="stylesheet" href="PATH">
    <script src="d3/d3.min.js"></script>
    <!--[if lt IE 9]>
       <script src = "http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
     <![endif]-->
    <style>
        body {
            font-family: sans-serif;
        }

        div.tooltip {
            position: absolute;
            text-align: center;
            vertical-align: middle;
            /*width: 100px;*/
            width: auto;
            height: auto;
            padding: 8px 5px;
            font: 12px sans-serif;
            color: white;
            background: black;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <h1> Compiling The Hop Chronicles Data: Br&uuml;losophy </h1>
    <div id="optionsId">
        <input type="radio" class="senseOption" name="sense" value="aroma" checked> AROMA
        <br>
        <input type="radio" class="senseOption" name="sense" value="flavor"> FLAVOR
        <br>
        <input type="checkbox" id="hideHops">Hide unselected hops
    </div>
    <div class="tooltip" style="opacity: 0"></div>
    <div id="radarChartId" style="display: inline-block;"></div>
    <div id="legendId" style="display: inline-block; padding-left: 25px"></div>
    <div id="barChartId"></div>

    <script>
        // The basic code for the radar chart was written by Nadieh Bremer (visualcinnamon.com).
        // See the Block here: http://bl.ocks.org/nbremer/21746a9668ffdf6d8242
        // and Nadieh's blog post here: https://www.visualcinnamon.com/2015/10/different-look-d3-radar-chart.html
        // Much of RadarChart has been omitted, and the general use has been modified to
        // facilitate this visualization. Config variable names have been added and changed, so re-use with caution.
        // (Her design in turn was based on alangrafu's radar-chart-d3: https://github.com/alangrafu/radar-chart-d3)

        ////////////////////////////////////////////////////////////////
        //                RADAR VARIABLES AND CHART                   //
        ////////////////////////////////////////////////////////////////

        var cfg = {
            w: 500, //Width of the circle
            h: 500, //Height of the circle
            margin: {
                top: 50,
                right: 50,
                bottom: 50,
                left: 50
            }, //The margins of the SVG
            levels: 3, //How many levels or inner circles should there be drawn
            maxValue: 7, //What is the value that the biggest circle will represent
            labelFactor: 1.1, //How much farther than the radius of the outer circle should the labels be placed
            wrapWidth: 60, //The number of pixels after which a label needs to be given a new line
            opacityArea: 0.35, //The opacity of the area of the blob
            dotRadius: 4, //The size of the colored circles of each blog
            opacityCircles: 0.05, //The opacity of the circles of each blob
            strokeWidth: 1, //The width of the stroke around each blob
            roundStrokes: false, //If true the area and stroke will follow a round path (cardinal-closed)
            // color: d3.scaleOrdinal(d3.schemeCategory20), //Color function
            color: ["red", "blue", "green", "orange", "purple"],
            radarColor: {
                show: {
                    flavor: "#002057",
                    aroma: "#a61e1e"
                },
                hide: {
                    flavor: "none",
                    aroma: "none"
                }
            },
            radarOpacity: 0.4
        };

        var dims = ['CITRUS', 'TROPICAL FRUIT', 'STONE FRUIT', 'APPLE-PEAR',
            'MELON', 'BERRY', 'FLORAL', 'SPICY-HERBAL', 'PINE', 'RESINOUS',
            'GRASSY', 'EARTHY-WOODY', 'ONION-GARLIC', 'DANK-CATTY'
        ];

        var senses = ["aroma", "flavor"];

        var maxValue = cfg.maxValue;
        var allAxis = dims, //Names of each axis
            total = allAxis.length, //The number of different axes
            radius = Math.min(cfg.w / 2, cfg.h / 2), //Radius of the outermost circle
            angleSlice = Math.PI * 2 / total; //The width in radians of each "slice"

        var showOrHide = "show",
            selectedSense = selectedSense = d3.select("input[name='sense']:checked").property("value"),
            vizStatus = {},
            nSel = 0;

        //Scale for the radius
        var rScale = d3.scaleLinear()
            .range([0, radius])
            .domain([0, maxValue]);

        //Initiate the radar chart SVG
        var g = d3.select("#radarChartId").append("svg")
            .attr("width", cfg.w + cfg.margin.left + cfg.margin.right)
            .attr("height", cfg.h + cfg.margin.top + cfg.margin.bottom)
            .append("g")
            .attr("transform", "translate(" + (cfg.w / 2 + cfg.margin.left) + "," + (cfg.h / 2 + cfg.margin.top) + ")");

        var legend = d3.select("#legendId").append("svg")
            .attr("width", 300)
            .attr("height", cfg.h)
            .append("g");

        //Wrapper for the grid & axes
        var axisGrid = g.append("g").attr("class", "axisWrapper");

        //Draw the background circles
        axisGrid.selectAll(".levels")
            .data(d3.range(1, (cfg.levels + 1)).reverse())
            .enter()
            .append("circle")
            .attr("class", "gridCircle")
            .attr("r", function(d, i) {
                return radius / cfg.levels * d;
            })
            .style("fill", "#CDCDCD")
            .style("stroke", "#CDCDCD")
            .style("fill-opacity", cfg.opacityCircles);

        //Text indicating at what % each level is
        axisGrid.selectAll(".axisLabel")
            .data(d3.range(1, (cfg.levels + 1)).reverse())
            .enter().append("text")
            .attr("class", "axisLabel")
            .attr("x", 4)
            .attr("y", function(d) {
                return -d * radius / cfg.levels;
            })
            .attr("dy", "0.4em")
            .style("font-size", "10px")
            .attr("fill", "#737373")
            .text(function(d, i) {
                return d3.format(".2f")(maxValue * d / cfg.levels);
            });

        //Create the straight lines radiating outward from the center
        var axis = axisGrid.selectAll(".axis")
            .data(allAxis)
            .enter()
            .append("g")
            .attr("class", "axis");
        //Append the lines
        axis.append("line")
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", function(d, i) {
                return rScale(maxValue * 1.1) * Math.cos(angleSlice * i - Math.PI / 2);
            })
            .attr("y2", function(d, i) {
                return rScale(maxValue * 1.1) * Math.sin(angleSlice * i - Math.PI / 2);
            })
            .attr("class", "line")
            .style("stroke", "white")
            .style("stroke-width", "2px");

        //Append the labels at each axis
        axis.append("text")
            .attr("class", "legend")
            .style("font-size", "11px")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .attr("x", function(d, i) {
                return rScale(maxValue * cfg.labelFactor) * Math.cos(angleSlice * i - Math.PI / 2);
            })
            .attr("y", function(d, i) {
                return rScale(maxValue * cfg.labelFactor) * Math.sin(angleSlice * i - Math.PI / 2);
            })
            .text(function(d) {
                return d
            })
            .call(wrap, cfg.wrapWidth);

        var radarLine = d3.radialLine()
            // .interpolate("linear-closed")
            .radius(function(d) {
                return rScale(d.value);
            })
            .angle(function(d, i) {
                return i * angleSlice;
            })
            .curve(d3.curveLinearClosed); // new version of interpolation I think

        function extractAvgs(hopData, sense) {
            return hopData.data.map(function(d) {
                return {
                    axis: d.dimension,
                    value: d3.mean(d[sense])
                }
            })
        }

        ////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////
        //                BARPLOT VARIABLES AND CHART                 //
        ////////////////////////////////////////////////////////////////
        var barCfg = {
            margin: {
                top: 30,
                right: 20,
                bottom: 50,
                left: 50
            },
            width: 800,
            height: 125,
        }

        var xDim = d3.scaleBand()
            .domain(dims)
            .rangeRound([0, barCfg.width])
            .paddingInner(0.15);

        var xSense = d3.scaleBand()
            .domain(senses)
            .rangeRound([0, xDim.bandwidth()])
            .paddingOuter(0.4);

        var dataRadius = xSense.bandwidth() / 5,
            barWidth = dataRadius * 3
        barHeight = 4;

        var y = d3.scaleLinear()
            .domain([0, 9])
            .range([barCfg.height, 0])

        var yAxis = d3.axisLeft(y)
            .ticks(3)
            .tickSizeOuter(0);

        var t = d3.transition().duration(200);

        var barPlot = d3.select("#barChartId").append("svg")
            .attr("width", barCfg.width + barCfg.margin.left + barCfg.margin.right)
            .attr("height", barCfg.height + barCfg.margin.top + barCfg.margin.bottom)
            .append("g")
            .attr("transform", "translate(" + barCfg.margin.left + "," + barCfg.margin.top + ")");

        barPlot.append("text")
            .attr("id", "barPlotHop")
            .attr("y", -barCfg.margin.top / 2)
            .attr("text-anchor", "start");

        barPlot.selectAll(".dimLabel")
            .data(dims)
            .enter()
            .append("text")
            .attr("x", function(d) {
                return xDim(d);
            })
            .attr("y", barCfg.height + barCfg.margin.bottom / 2)
            .text(function(d) {
                return d;
            })
            .attr("text-anchor", "start")
            .attr("font-size", 8)
            .attr("dy", 0)
            .call(wrap, xDim.bandwidth());

        barPlot.append("g")
            .attr("transform", "translate(-10, 0)")
            .call(yAxis);

        barPlot.selectAll(".dimBox")
            .data(dims, function(d) {
                return d;
            })
            .enter()
            .append("g")
            .classed("dimBox", 1)
            .attr("transform", function(d) {
                return "translate(" + xDim(d) + ",0)";
            });

        // function to plot radar data the first time
        function setupRadar() {
            d3.json("hop_data/all_hop_data.json", function(data) {

                data.forEach(function(d) {
                    vizStatus[d.hop] = 0;
                });

                var labelSpacing = cfg.h / (data.length + 1)

                var blobWrapper = g.selectAll(".radarWrapper")
                    .data(data, function(d, i) {
                        return d.hop;
                    });

                blobWrapper
                    .enter().append("g")
                    .attr("class", "radarWrapper")
                    .append("path")
                    .attr("class", "radarStroke")
                    .attr("id", function(d) {
                        return d.hop + "Radar";
                    })
                    .attr("d", function(d, i) {
                        return radarLine(extractAvgs(d, selectedSense));
                    })
                    .style("stroke-opacity", cfg.radarOpacity)
                    .style("stroke", cfg.radarColor[showOrHide][selectedSense])
                    .style("stroke-width", cfg.strokeWidth)
                    .style("fill", "none")
                    .on("mouseover", function(d) {
                        if (!vizStatus[d.hop]) {
                            alterRadar(this.id, "black", 4, 1.0);
                        }
                        tooltip.html(d.hop.toUpperCase())
                            .style("opacity", 1.0)
                            .style("left", (d3.event.pageX + 10) + "px")
                            .style("top", (d3.event.pageY) + "px");
                    })
                    .on("mouseout", function(d) {
                        tooltip.style("opacity", 0);
                        if (!vizStatus[d.hop]) {
                            alterRadar(this.id, cfg.radarColor[showOrHide][selectedSense], cfg.strokeWidth, cfg.radarOpacity);
                        }
                    });

                var hopLabels = legend.selectAll(".hopLabel")
                    .data(data.map(function(d) {
                        return d.hop;
                    }), function(d) {
                        return d;
                    })
                    .enter()
                    .append("g")
                    .attr("class", "hopLabelGroup")
                    .attr("transform", function(d, i) {
                        return "translate(0," + labelSpacing * (i + 1) + ")";
                    });

                hopLabels.append("text")
                    .attr("class", "hopLabel")
                    .style("cursor", "pointer")
                    .text(function(d) {
                        return d.toUpperCase();
                    })
                    .on("mouseover", function(d, i) {
                        if (!vizStatus[d]) {
                            alterRadar(d + "Radar", "black", 4, 1.0)
                        }
                    })
                    .on("mouseout", function(d, i) {
                        if (!vizStatus[d]) {
                            alterRadar(d + "Radar", cfg.radarColor[showOrHide][selectedSense], cfg.strokeWidth, cfg.radarOpacity)
                        }
                    })
                    .on("click", function(d, i) {
                        var truth = vizStatus[d]
                        var label = d3.select(this);

                        if (!truth) {
                            if (nSel >= 5) alert("You can select a max of 5 hops.")
                            else {
                                nSel++;
                                label.style("fill", cfg.color[nSel-1])
                                alterRadar(d + "Radar", cfg.color[nSel-1], 4, 1.0)
                                plotBars(d);
                                vizStatus[d] = (truth + 1) % 2;
                            }
                        } else {
                            nSel--;
                            label.style("fill", "black")
                            alterRadar(d + "Radar", cfg.radarColor[showOrHide][selectedSense], cfg.strokeWidth, cfg.radarOpacity)
                            vizStatus[d] = (truth + 1) % 2;
                        }
                    });
            }) //json callback
        } // addData

        var tooltip = d3.select(".tooltip")

        // show/hide unselected hops based on checkbox
        d3.select("#hideHops")
            .property("checked", false)
            .on("change", function() {
                checked = d3.select(this).property("checked");
                showOrHide = checked ? "hide" : "show";
                d3.selectAll(".radarStroke").each(function(d) {
                    if (!vizStatus[d.hop]) d3.select(this).style("stroke", cfg.radarColor[showOrHide][selectedSense]);
                });
            });

        // plot radars based on sense/aroma option
        d3.selectAll(".senseOption")
            .on("change", function() {
                selectedSense = d3.select("input[name='sense']:checked").property("value");
                plotRadars(selectedSense);
            });

        // function to plot sense or aroma data and appropriate color
        function plotRadars(sense) {
            d3.selectAll(".radarStroke")
                .attr("d", function(d) {
                    return radarLine(extractAvgs(d, sense));
                })
                // .style("stroke", cfg.radarColor[showOrHide][sense])
                .style("stroke", function(d) { return vizStatus[d.hop] ? d3.select(this).style("stroke") : cfg.radarColor[showOrHide][sense] })
        }

        // function to modify look of radar based on selection/hovering
        function alterRadar(hopId, color, thickness, opacity) {
            d3.select("#" + hopId)
                .style("stroke-width", thickness)
                .style("stroke", color)
                .style("stroke-opacity", opacity);
        }

        // function to plot bar data
        function plotBars(hop) {

            d3.select("#barPlotHop").text(hop.toUpperCase());

            var hopData = d3.select("#" + hop + "Radar").datum();
            var dimBoxes = d3.selectAll(".dimBox")
                // .data(hopData.data, function(d) { return d.dimension; });
                .data(hopData.data);

            var senseGroups = dimBoxes.selectAll(".senseData")
                .data(function(d) {
                    return senses.map(function(s) {
                        return {
                            sense: s,
                            values: d[s]
                        };
                    })
                });

            senseGroups.enter()
                .append("g")
                .attr("class", function(d) {
                    return "senseData " + d.sense + "Data";
                })
                .attr("transform", function(d) {
                    return "translate(" + xSense(d.sense) + ",0)";
                });

            senseGroups = d3.selectAll(".senseData");

            var meanBars = senseGroups.selectAll(".meanBar")
                .data(function(d) {
                    return [{
                        sense: d.sense,
                        avg: d3.mean(d.values)
                    }];
                });

            meanBars.enter()
                .append("rect")
                .classed("meanBar", 1)
                .attr("x", -barWidth / 2)
                .attr("width", barWidth)
                .style("fill", "white")
                .style("stroke", function(d) {
                    return cfg.radarColor["show"][d.sense]
                })
                .on("mouseover", function(d) {
                    tooltip.html(d3.format("0.2f")(d.avg))
                        .style("opacity", 1.0)
                        .style("left", (d3.event.pageX + 10) + "px")
                        .style("top", (d3.event.pageY) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("opacity", 0);
                })
                .merge(meanBars)
                .transition(t)
                .attr("y", function(d) {
                    return y(d.avg)
                })
                .attr("height", function(d) {
                    return y(0) - y(d.avg)
                });

            var dataPoints = senseGroups.selectAll(".dataPoint")
                .data(function(d) {
                    return d.values;
                });
            dataPoints.exit().transition(t).remove();

            dataPoints.enter()
                .append("circle")
                .classed("dataPoint", 1)
                .attr("r", dataRadius)
                .attr("fill", "black")
                .attr("fill-opacity", 0.1)
                .merge(dataPoints)
                .transition(t)
                .attr("cy", function(d) {
                    return y(d);
                });

        }

        setupRadar();

        //Taken from http://bl.ocks.org/mbostock/7555321
        //Wraps SVG text
        function wrap(text, width) {
            text.each(function() {
                var text = d3.select(this),
                    words = text.text().split(/[\s\-]/).reverse(),
                    word,
                    line = [],
                    lineNumber = 0,
                    lineHeight = 1.4, // ems
                    y = text.attr("y"),
                    x = text.attr("x"),
                    dy = parseFloat(text.attr("dy")),
                    tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");

                while (word = words.pop()) {
                    line.push(word);
                    tspan.text(line.join(" "));
                    if (tspan.node().getComputedTextLength() > width) {
                        line.pop();
                        tspan.text(line.join(" "));
                        line = [word];
                        tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                    }
                }
            });
        }
    </script>


</body>

</html>
